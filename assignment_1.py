# -*- coding: utf-8 -*-
"""assignment_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1198FnHXl6I3HBf3MBLEhNirbsg1YC_cu

NAME:   Sadia Amin

ID:     bsf24000325

Q1. MATRIX OPERATION AND TRACE.
"""

# a) Compute C = A + 2B

import numpy as np
A= np.array([[2,-1,0],[-1,2,-1],[0,-1,2]])
B= np.array([[1,2,3],[0,-1,4],[2,0,1]])
C= np.add(A,2*B)
print("C= ",C)

# b) Compute D = A . B

A= np.array([[2,-1,0],[-1,2,-1],[0,-1,2]])
B= np.array([[1,2,3],[0,-1,4],[2,0,1]])
D = np.dot(A,B)
print("D= ",D)

# c) Compare 𝑡𝑟𝑎𝑐𝑒(𝐷) with 𝑡𝑟𝑎𝑐𝑒(𝐴).𝑡𝑟𝑎𝑐𝑒(𝐵).

A= np.array([[2,-1,0],[-1,2,-1],[0,-1,2]])
B= np.array([[1,2,3],[0,-1,4],[2,0,1]])
D= np.dot(A,B)
trace_D = np.trace(D)
trace_A = np.trace(A)
trace_B = np.trace(B)
print("trace(A) =", trace_A)
print("trace(B) =", trace_B)
print("trace(A)*trace(B) =", trace_A * trace_B)
print("trace(D) =", trace_D)

# Compare
if trace_D == trace_A * trace_B:
    print("trace(D) = trace(A)*trace(B)")
else:
    print("trace(D) ≠ trace(A)*trace(B)")

"""Q2. SYMMETRY & HIDDEN STRUCTURE."""

# C) Verify with Python by reconstructing 𝐴 from 𝑀𝑇𝑀.

A= np.array([[2,-1,0],[-1,2,-1],[0,-1,2]])

M, R = np.linalg.qr(A)   # QR decomposition

# Reconstruct A
A_reconstructed = M @ R

print("Original A:\n", A)
print("\nM (Q matrix):\n", M)
print("\nR matrix:\n", R)
print("\nM @ R (reconstructed A):\n", A_reconstructed)

# Check closeness
if np.allclose(A, A_reconstructed):
    print("\nVerification successful: A = M @ R")
else:
    print("\nVerification failed: A ≠ M @ R")

"""Q3. POLYNOMIAL IN MATRICES."""

# a) Compute P(A) = A^2 - 3A + 2*I

A = np.array([[2, -1, 0],[-1, 2, -1],[0, -1, 2]])

def matrix_polynomial(A, coeffs):
    result = np.zeros_like(A, dtype=complex)  # Use complex for matrix powers
    I = np.eye(A.shape[0])
    for power, c in enumerate(coeffs):
        if power == 0:
            term = I
        else:
            term = np.linalg.matrix_power(A, power)
        result += c * term
    return result

# coefficients for A^2 -3A +2I:
coeffs = [2, -3, 1]  # c0=2I, c1=-3A, c2=1*A^2

P_A = matrix_polynomial(A, coeffs)
print("P(A)=\n", P_A)

# b) Verify whether 𝑃(𝐴) = 0 (Cayley–Hamilton theorem).

import numpy as np

A = np.array([[2, -1, 0],[-1, 2, -1],[0, -1, 2]])

# Identity matrix
I = np.eye(A.shape[0])

# Characteristic polynomial: λ^3 - 6λ^2 + 10λ - 4
# So p(A) = A^3 - 6A^2 + 10A - 4I
P_A = np.linalg.matrix_power(A, 3) - 6*np.linalg.matrix_power(A, 2) + 10*A - 4*I

print("P(A) =",P_A)

# c) In Python, check np.allclose(PA, np.zeros_like(A)).

print("\nIs P(A) the zero matrix?")
print(np.allclose(P_A, np.zeros_like(A)))

"""Q4. ORTHOGONAL & UNITARY."""

# a) Generate a 3 × 3 real matrix in Python.


A = np.random.randint(1, 10, size=(3, 3))
print("Matrix A:\n", A)



# b) Normalize its columns to form 𝑄.

Q = A / np.linalg.norm(A, axis=0)
print("Matrix Q (with normalized columns):\n", Q)


# c) Check whether 𝑄 is orthogonal.

I = np.eye(3)
print("Is Q orthogonal? ->", np.allclose(Q.T @ Q, I))


# d) Extend to complex entries and check whether the resulting 𝑈 is unitary

# Complex version
A_complex = np.random.randint(1, 10, size=(3, 3)) + 1j*np.random.randint(1, 10, size=(3, 3))
U = A_complex / np.linalg.norm(A_complex, axis=0)

print("Matrix U (complex normalized):\n", U)
print("Is U unitary? ->", np.allclose(U.conj().T @ U, I))

"""Q5. CREATIVE EXPLORATION"""

# b) Verify triangle inequality |𝑢 + 𝑣| ≤ |𝑢| + |𝑣| manually and in Python.

u = np.array([1, 2, -2])
v = np.array([3, -12, 4])
norm_u = np.linalg.norm(u)
norm_v = np.linalg.norm(v)
norm_u_plus_v = np.linalg.norm(u + v)

print("||u|| = ",norm_u)
print("||v|| = ",norm_v)
print("||u + v|| = ",norm_u_plus_v)
print("|𝑢 + 𝑣| ≤ |𝑢| + |𝑣| = ",norm_u_plus_v <= norm_u + norm_v)
