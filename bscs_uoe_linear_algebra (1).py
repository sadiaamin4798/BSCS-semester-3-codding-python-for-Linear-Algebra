# -*- coding: utf-8 -*-
"""BSCS_UoE_Linear_Algebra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WG54wf1zuCv4I9gVXKpmP6koN2OSkJk3
"""

# Run this cell first
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

print("Environment Ready ✅ (NumPy + Matplotlib)")

# Q1: Normalize vectors
u = np.array([5, -7])
v = np.array([1, 2, -2, 4])

# Normalization
def normalize(x):
    return x / np.linalg.norm(x)

u_norm = normalize(u)
print("u normalized:", u_norm)

# Plot (2D example only for u)
plt.figure()
plt.quiver(0,0,u[0],u[1],angles='xy',scale_units='xy',scale=1,color='r',label='u')
plt.quiver(0,0,u_norm[0],u_norm[1],angles='xy',scale_units='xy',scale=1,color='b',label='u normalized')
plt.axhline(0,color='k'); plt.axvline(0,color='k')
plt.legend(); plt.title("Q1: Normalization of Vector u")
plt.axis([-8, 8, -8, 8]);  # manual axis range
plt.grid()
plt.show()



# Q2: Triangle inequality demonstration
u = np.array([1, 2, -2])
v = np.array([3, -12, 4])

u_plus_v = u + v

print("||u|| =", np.linalg.norm(u))
print("||v|| =", np.linalg.norm(v))
print("||u+v|| =", np.linalg.norm(u_plus_v))
print("Triangle Inequality Check: ", np.linalg.norm(u_plus_v), "<=", np.linalg.norm(u)+np.linalg.norm(v))

# 3D Plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.quiver(0,0,0,u[0],u[1],u[2],color='r',label='u')
ax.quiver(0,0,0,v[0],v[1],v[2],color='b',label='v')
ax.quiver(0,0,0,u_plus_v[0],u_plus_v[1],u_plus_v[2],color='g',label='u+v')
ax.set_title("Q2: Triangle Inequality Visualization")
ax.legend()
plt.show()

# Q4. Hyperplane equations in R^4

# (a) Contains P and is normal to u
P = np.array([1, 2, -3, 2])
u = np.array([2, 3, -5, 6])
d = np.dot(u, P)
print("Equation: 2x1 + 3x2 - 5x3 + 6x4 =", d)

# (b) Contains P and is parallel to given plane
P = np.array([3, -1, 2, 5])
# Normal vector is same: [2, -3, 5, -7]
normal = np.array([2, -3, 5, -7])
d = np.dot(normal, P)
print("Equation: 2x1 - 3x2 + 5x3 - 7x4 =", d)

# Q6: Curve in R^3
t = np.linspace(0,5,100)
F = np.array([t**3, -t**2, 2*t-3])

t_point = 2
P = np.array([t_point**3, -t_point**2, 2*t_point-3])

# Tangent vector at t=2
dF = np.array([3*t_point**2, -2*t_point, 2])

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(F[0], F[1], F[2], 'b', label="Curve C")
ax.scatter(P[0], P[1], P[2], color='r', s=50, label="Point at t=2")
ax.quiver(P[0],P[1],P[2],dF[0],dF[1],dF[2],color='g',length=5,normalize=True,label="Tangent")

ax.set_title("Q6: Curve and Tangent in R^3")
ax.legend()
plt.show()

# Q7: Orthogonal vector using cross product
v = np.array([1, 3, 4])
w = np.array([2, -6, -5])
u = np.cross(v, w)
u = u / np.linalg.norm(u)  # normalize
print("Unit orthogonal vector:", u)

# Plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.quiver(0,0,0,v[0],v[1],v[2],color='r',label='v')
ax.quiver(0,0,0,w[0],w[1],w[2],color='b',label='w')
ax.quiver(0,0,0,u[0],u[1],u[2],color='g',label='u orthogonal')
ax.set_title("Q7: Orthogonal Vector via Cross Product")
ax.legend()
plt.show()

# Q8  vectors + visible arrowheads + parallelepiped faces
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

# vectors
u = np.array([3, -4, 2])
v = np.array([2, 5, -3])
w = np.array([4, 7, 2])

# volume
volume = abs(np.dot(u, np.cross(v, w)))
print("Volume of parallelepiped:", volume)

# prepare 3D figure
fig = plt.figure(figsize=(9,9))
ax = fig.add_subplot(111, projection='3d')

# compute sensible axis limits (centered cube, so aspect looks correct)
pts = np.vstack([np.zeros(3), u, v, w, u+v, u+w, v+w, u+v+w])
mins = pts.min(axis=0)
maxs = pts.max(axis=0)
center = (mins + maxs) / 2.0
max_range = (maxs - mins).max()
padding = 0.6  # increase to give more space for arrowheads
R = max_range * (1 + padding)

ax.set_xlim(center[0] - R/2, center[0] + R/2)
ax.set_ylim(center[1] - R/2, center[1] + R/2)
ax.set_zlim(center[2] - R/2, center[2] + R/2)

# draw full-length vectors as lines (so magnitude is visible)
ax.plot([0, u[0]], [0, u[1]], [0, u[2]], color='r', linewidth=2)
ax.plot([0, v[0]], [0, v[1]], [0, v[2]], color='b', linewidth=2)
ax.plot([0, w[0]], [0, w[1]], [0, w[2]], color='g', linewidth=2)

# mark endpoints
ax.scatter([u[0]], [u[1]], [u[2]], color='r', s=40)
ax.scatter([v[0]], [v[1]], [v[2]], color='b', s=40)
ax.scatter([w[0]], [w[1]], [w[2]], color='g', s=40)

# draw direction arrows (unit arrows) so arrowheads remain visible
# choose direction-arrow length as fraction of plot size
dir_len = 0.18 * R
ax.quiver(0, 0, 0, u[0], u[1], u[2], length=dir_len, normalize=True, color='r', linewidth=1)
ax.quiver(0, 0, 0, v[0], v[1], v[2], length=dir_len, normalize=True, color='b', linewidth=1)
ax.quiver(0, 0, 0, w[0], w[1], w[2], length=dir_len, normalize=True, color='g', linewidth=1)

# OPTIONAL: draw parallelepiped faces (semi-transparent)
O = np.array([0,0,0])
A = u
B = v
C = w
# 8 corner points
corners = {
    'O':O, 'A':A, 'B':B, 'C':C,
    'A+B':A+B, 'A+C':A+C, 'B+C':B+C, 'A+B+C':A+B+C
}
# faces as lists of corner coordinates (each face is a quad)
faces = [
    [corners['O'], corners['A'], corners['A+B'], corners['B']],
    [corners['O'], corners['A'], corners['A+C'], corners['C']],
    [corners['O'], corners['B'], corners['B+C'], corners['C']],
    [corners['A+B'], corners['A+B+C'], corners['A+C'], corners['A']],
    [corners['B+C'], corners['A+B+C'], corners['A+C'], corners['C']],
    [corners['A+B'], corners['A+B+C'], corners['B+C'], corners['B']]
]
poly = Poly3DCollection(faces, facecolors='cyan', alpha=0.15, edgecolor='grey')
ax.add_collection3d(poly)

# labels and title
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Q8: Vectors in R^3 and Parallelepiped (volume = {:.2f})'.format(volume))

plt.show()

# Q9: Complex vectors in C^2
u = np.array([1+7j, 2-6j])
v = np.array([5-2j, 3-4j])

# Operations
print("u+v =", u+v)
print("(3+i)u =", (3+1j)*u)
print("2iu+(4+7i)v =", 2j*u + (4+7j)*v)
print("u.v =", np.vdot(u,v))
print("||u|| =", np.linalg.norm(u))
print("||v|| =", np.linalg.norm(v))

# Plot in complex plane
plt.figure(figsize=(8,8))

vectors = [u[0], u[1], v[0], v[1]]
labels  = ["u[0] = 1+7i", "u[1] = 2-6i", "v[0] = 5-2i", "v[1] = 3-4i"]
colors  = ["r", "g", "b", "m"]

for comp, label, color in zip(vectors, labels, colors):
    plt.quiver(0, 0, comp.real, comp.imag,
               angles='xy', scale_units='xy', scale=1,
               color=color, label=label, width=0.006, headwidth=4, headlength=6)

# Axes & styling
plt.axhline(0, color='k', linewidth=1)
plt.axvline(0, color='k', linewidth=1)
plt.title("Q9: Complex Vectors in Argand Plane (C²)")
plt.xlabel("Real axis"); plt.ylabel("Imag axis")
plt.legend(); plt.grid(); plt.axis('equal')

# Auto zoom-out with padding
all_points = np.array([[z.real, z.imag] for z in vectors])
x_min, y_min = all_points.min(axis=0) - 5
x_max, y_max = all_points.max(axis=0) + 5
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)

plt.show()